package mgogen // import "github.com/evergreen-ci/mgogen"

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"text/template"
)

type Generator struct {
	buf         bytes.Buffer //accumulated output.
	file        string
	typeName    string
	template    string
	packageName string
	structInfo  *ast.StructType
}

var templ = template.Must(
	template.New("output").Parse(`
// generated by orm generator - do not edit.
package {{.PackageName}}

import (
	"{{.Mgo}}"
)

type {{.WrapperName}} struct {
	session *mgo.Session
	db string
	collection string
}

func ({{.Receiver}}) C() *mgo.C {
	return {{.Short}}.session.DB()
}

func ({{.Receiver}}) Do(q Q) ([]{{.TypeName}}, error) {
	ses := {{.Short}}.session.Copy()
	out := []{{.TypeName}}{}
	err := q.ToQuery(ses, {{.Short}}.dbName, {{.Short}}.collection).All(&out)
	ses.Close()
	return out, err
}

func ({{.Receiver}}) FindOne(q interface{}) ([]*{{.TypeName}}, error) {
	query := Q{query:q}
	ses := {{.Short}}.session.Copy()
	out := new({{.TypeName}})
	err := q.ToQuery(ses, {{.Short}}.dbName, {{.Short}}.collection).All(&out)
	ses.Close()
	if err == mgo.ErrNotFound {
		return nil, nil
	}
	return out, err
}

`),
)

func (g *Generator) locateType(n ast.Node) bool {
	switch x := n.(type) {
	case *ast.TypeSpec:
		switch y := x.Type.(type) {
		case *ast.StructType:
			if x.Name.String() == g.typeName {
				g.structInfo = y
			}
		default:
			//
		}
	case *ast.File:
		g.packageName = x.Name.String()
	default:
	}
	return true
}

type OutputData struct {
	Short       string // single-char name used for receiver value
	Receiver    string
	TypeName    string // name of the model
	WrapperName string // name of the wrapper for the collection
	PackageName string
	Mgo         string
}

func (g *Generator) Generate() ([]byte, error) {
	wrapperName := g.typeName + "Coll"
	err := templ.ExecuteTemplate(&g.buf, "output", OutputData{
		Short:       g.typeName[0:1],
		TypeName:    g.typeName,
		WrapperName: wrapperName,
		PackageName: g.packageName,
		Receiver:    fmt.Sprintf("%s %s", g.typeName[0:1], wrapperName),
		Mgo:         "gopkg.in/mgo.v2",
	})
	if err != nil {
		return nil, err
	}

	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Only happens if the generated source has a syntax error.
		// in that case, just return the un-formatted bytes so the user
		// can see the error at compile.
		log.Printf("warning - generated output contained gofmt errors: %v\n", err)
		return g.buf.Bytes(), nil
	}
	return src, nil
}

func (g *Generator) Parse() error {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, g.file, nil, 0)
	if err != nil {
		return err
	}
	ast.Inspect(f, g.locateType)
	if g.structInfo == nil {
		return fmt.Errorf("Can't find type %v in file %v\n", g.typeName, g.file)
	}
	return nil
}

func NewGenerator(typeName, file string) *Generator {
	return &Generator{typeName: typeName, file: file}
}
